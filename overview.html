<html>
    <body>
        Frameworks purpose is to synchronize generic relational databases in heterogenous network.
        <div>
            To start using the framework, do as follows:<br/>
            <ol>
                <li>
                    <a href="#configuration">Configure</a> the framework (on both server and client)
                </li>
                <li>
                    On the <a href="#server">server</a>:
                    write the code to process the client's synchronization request, pass it on to
                    {@link de.consistec.syncframework.common.SyncContext.ServerContext Server Sync Context}
                    and return it to the client.
                </li>
                <li>
                    On the <a href="#client">client</a>:
                    just invoke the {@link de.consistec.syncframework.common.SyncContext.ClientContext#synchronize()}
                    method. <br/>E.g.:<br/>
                    <code>
                        final SyncContext.ClientContext clientCtx = SyncContext.ClientContext.create();<br/>
                        clientCtx.synchronize();
                    </code>
                </li>
            </ol>
        </div>
        <br/>

        <h3><a name="configuration">1. Configure the framework</a></h3>

        <p>
            To use the framework, you must to configure it first.<br/>
            You can set all configuration options directly from the code, using setters of
            {@link de.consistec.syncframework.common.Config config singleton} or loading them from a file.
            To load from a file use
            {@link de.consistec.syncframework.common.Config#loadFromFile(java.io.InputStream) loadFromFile(InputStream)}
            method. A sample file can be found in the root package of commmon.jar with the name
            <code>syncframework_template.properties</code>.
        </p>

        <p>
            {@link de.consistec.syncframework.common.Config Configuration} class is a singleton, so you should obtain
            its instance like this: <br/>
            <code>private static final Config CONF = Config.getInstance();</code>
        </p>

        <p>
            The first usage of framework's classes have to be preceded by code which sets the values on CONF instance.
            It can be done in a static block or some other place which is an entry/starting point of your application.
        </p>

        <div>
            The easiest way of propagating configuration is to provide a <code>.properties</code> file.<br>
            <br/>E.g.:<br/>
            <pre>
            File file = new File(context.getRealPath("/WEB-INF/" + fileName));
            Config conf = Config.getInstance();
            try {
                conf.loadFromFile(new FileInputStream(file));
            } catch (IOException ex) {
                // handle exception ...
            }
            </pre>
        </div>
        <p>
            Note that not all options have to be provided. On the server, there is no need to provide options that concern
            client operations and vice versa.<br/>
            Also, when one wants to use the client synchronization provider together with the server provider in one application
            (so called {@link de.consistec.syncframework.common.SyncContext.LocalContext "LocalContext"}),
            there is no need to specify the server proxy class and its configuration.
        </p>

        <h3><a name="server">2. Server side processing</a></h3>

        <p>
            The most work to do is when clients are to be synchronized with the remote server.<br/>
            {@link de.consistec.syncframework.common.SyncContext.ClientContext ClientContext} uses a class specified in
            the configuration as a server provider proxy, to send and receive data from the server.
        </p>

        <p>
            These proxies have to be written by the developer, because they are specific to a transport protocol used to
            communicate with the server. An example proxy implementation for the Http protocol,
            based on JEE Servlet technology, can be found in the 
            {@link de.consistec.syncframework.impl.proxy.http_servlet} package. The proxy is used by the
            {@link de.consistec.syncframework.common.SyncContext.ClientContext ClientContext}
            on the client's side of the synchronization, but without developers interference in that matter.
        </p>

        <p>
            To write a proxy appropriate for your purpose, implement the
            {@link de.consistec.syncframework.common.server.IServerSyncProvider IServerSyncProvider} interface.<br/>
            Have a look at the {@link de.consistec.syncframework.impl.proxy.http_servlet.HttpServerSyncProxy HttpServerSyncProxy} class.
        </p>

        <p>
            On the server side, one needs a code to receive a request from the proxy, parse it and pass it on to the appropriate
            method of the {@link de.consistec.syncframework.common.SyncContext.ServerContext}. This code depends on
            communication protocol and system architecture, so it is impossible to write either a stub class or an interface for
            this task.<br/>
            Together with the {@link de.consistec.syncframework.impl.proxy.http_servlet.HttpServerSyncProxy Http proxy}, we also 
            provide an {@link de.consistec.syncframework.impl.proxy.http_servlet.HttpServletProcessor Http servlet processor}, to
            do the tasks mentioned above.
        </p>

        <h3><a name="client">3. Client side processing</a></h3>

        <p>
            Besides the configuration, there is no special coding needed on the client. Just invoke the <code>synchronize()</code> method
            on ClientContext object:<br/>
            {@code SyncContext.ClientContext.create().synchronize();}<br/>
            You can register {@link de.consistec.syncframework.common.ISyncProgressListener progress listeners}
            on the client's context object, or add a {@link de.consistec.syncframework.common.IConflictListener conflict listener}
            to it.
        </p>
    </body>
</html>
